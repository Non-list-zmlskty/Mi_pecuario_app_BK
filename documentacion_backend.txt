DOCUMENTACIÓN BACKEND MIPECUARIO
================================

1. FLUJO DE EJECUCIÓN DETALLADO
-------------------------------

1.1 Inicio de la Aplicación (Aqui_empece.py):
    - Carga de variables de entorno
    - Inicialización de Flask
    - Configuración de CORS (permite headers de autenticación)
    - Registro del Blueprint de rutas
    - Configuración de ngrok para exponer la API
    - Inicio del servidor Flask

1.2 Configuración de Base de Datos (Base_De_Datos_cam.py):
    - Carga de variables de entorno para DB
    - Creación de URL de conexión
    - Configuración del engine y pool de conexiones
    - Configuración de la sesión (SessionLocal)
    - Creación de la base declarativa

1.3 Flujo de una Petición HTTP:
    a) Registro de Usuario (/api/usuarionuevo):
       - Recibe petición POST
       - Valida datos
       - Crea sesión DB (siempre se cierra con db.close())
       - Verifica usuario existente
       - Crea nuevo usuario
       - Guarda en DB
       - Genera tokens JWT
       - Retorna respuesta

    b) Login (/api/auth/login):
       - Recibe petición POST
       - Obtiene credenciales
       - Verifica usuario
       - Verifica contraseña
       - Genera tokens
       - Retorna respuesta

    c) Logout seguro (/api/auth/logout):
       - Recibe petición POST con token en header Authorization
       - El decorador verifica el token y la blocklist
       - El endpoint agrega el token a la blocklist (revoca el token)
       - Retorna mensaje de éxito

    d) Rutas protegidas:
       - Verificación de token y blocklist
       - Decodificación de token
       - Obtención de usuario actual
       - Ejecución de lógica protegida
       - Retorno de respuesta

1.4 Manejo de Errores:
    - Errores de validación
    - Errores de base de datos (rollback y cierre de sesión)
    - Errores de autenticación (token inválido, expirado, revocado)
    - Cierre de sesiones siempre con finally

2. CONFIGURACIÓN DE ENGINE Y SESIÓN
----------------------------------

2.1 Engine (Motor de Base de Datos):
    - Manejo de pool de conexiones
    - Traducción de operaciones SQLAlchemy a SQL
    - Gestión de transacciones

2.2 SessionLocal (Fábrica de Sesiones):
    - Creación y cierre de sesiones por petición
    - Manejo de ciclo de vida de transacciones
    - Contexto para operaciones DB

2.3 Uso correcto en el Código:
    - Siempre usar try/except/finally y cerrar la sesión con db.close()
    - Hacer db.rollback() en except si hay error
    - No compartir sesiones entre peticiones/hilos
    - No abrir sesiones dentro de bucles sin cerrarlas

3. JWT TOKENS Y BLOCKLIST
-------------------------

3.1 Estructura de Tokens:
    - Access Token (corta duración, 1 hora)
    - Refresh Token (larga duración, 30 días)
    - Payload con información de usuario
    - Firma con clave secreta

3.2 Blocklist (lista de tokens revocados):
    - Implementada como un set en memoria
    - Al hacer logout, el token se agrega a la blocklist
    - El decorador verifica la blocklist en cada petición protegida
    - Si el token está revocado, responde 401

3.3 Flujo de Logout:
    - Frontend envía POST /api/auth/logout con el token
    - Backend agrega el token a la blocklist
    - El token no puede usarse más, aunque no haya expirado
    - El frontend elimina el token localmente y redirige al login

4. BLUEPRINT Y RUTAS
-------------------

4.1 Registro de Blueprint:
    app.register_blueprint(api, url_prefix='/api')

4.2 Organización modular de rutas y lógica de negocio

4.3 Ejemplo de rutas:
    - /api/usuarionuevo (registro)
    - /api/auth/login (login)
    - /api/auth/logout (logout seguro)
    - /api/user/profile (perfil protegido)
    - /api/ingreso/mis-fichas (fichas protegidas)

5. MANEJO DE SESIONES Y ERRORES
------------------------------

5.1 Siempre cerrar la sesión con db.close() en finally
5.2 Hacer db.rollback() en except si hay error
5.3 No compartir sesiones entre peticiones/hilos
5.4 No abrir sesiones dentro de bucles sin cerrarlas
5.5 Si no se sigue esto, puedes tener errores como:
    - QueuePool limit of size 5 overflow 10 reached, connection timed out
    - Conexiones colgadas o lentitud
    - Estado inconsistente en la base de datos

6. SEGURIDAD Y BUENAS PRÁCTICAS
-------------------------------

6.1 Cambiar JWT_SECRET_KEY en producción
6.2 Configurar CORS adecuadamente
6.3 Usar HTTPS en producción
6.4 Implementar rate limiting si es necesario
6.5 No exponer datos sensibles en respuestas
6.6 Validar siempre los datos de entrada

7. PRUEBAS Y USO DE POSTMAN
---------------------------

7.1 Probar endpoints de login, registro, logout y rutas protegidas
7.2 Enviar el token en el header Authorization: Bearer <token>
7.3 Verificar que tras logout, el token no funcione más
7.4 Verificar respuestas de error y mensajes claros

8. ACTUALIZACIÓN DE DEPENDENCIAS Y USO DE POETRY
------------------------------------------------
- Instalar Poetry en el sistema (no dentro del repo)
- poetry install para instalar dependencias
- poetry update para actualizar
- poetry shell para activar entorno virtual
- Consultar la documentación oficial: https://python-poetry.org/docs/